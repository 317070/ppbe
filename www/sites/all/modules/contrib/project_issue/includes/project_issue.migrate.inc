<?php
/**
 * @file
 * Project issue D6 -> D7 migration.
 */

define('ISSUE_MIGRATE_TYPE_COMMENT', 0);
define('ISSUE_MIGRATE_TYPE_REVISION', 1);

define('ISSUE_MIGRATE_TIMELINE_OP', 0);
// Unfortunately, followups have to appear first so we have a semi-sane parent
// for existing revisions. The revisions will always appear later than reality,
// but since we don't know what reality IS due to revision corruption, there
// is not much we can do about it.
define('ISSUE_MIGRATE_TIMELINE_FOLLOWUP', 1);
define('ISSUE_MIGRATE_TIMELINE_REVISION', 2);
define('ISSUE_MIGRATE_TIMELINE_CURCHECK', 3);

// Uid used in cases of ambiguity -- Ownership of existing revisions is in doubt.
define('ISSUE_MIGRATE_SYSTEM_MIGRATION_USER', 180064); // Currently 'System Message'.

// Must not appear in file description field!
define('ISSUE_MIGRATE_FILE_DESCRIPTION_DELIMITER', '|||');
// Drupal.org specific!
define('ISSUE_MIGRATE_TAGS_VID', 9);

/**
 * Transfer initial uploads from upload to field_issue_files.
 */
class ProjectIssueFixInitFilesMigration extends MigrationBase {
  /**
   * General initialization of a ProjectIssueTimelineMigration object.
   */
  public function __construct() {
    parent::__construct();
    $this->description = t('WIP: USE AT YOUR OWN RISK! Move uploaded files to the correct field.');
  }

  protected function import() {
    db_query('INSERT INTO {field_data_field_issue_files} (SELECT * FROM {field_data_upload} WHERE entity_type = :type AND bundle = :bundle)', array(':type' => 'node', ':bundle' => 'project_issue'));
    db_query('INSERT INTO {field_revision_field_issue_files} (SELECT * FROM {field_revision_upload} WHERE entity_type = :type AND bundle = :bundle)', array(':type' => 'node', ':bundle' => 'project_issue'));
    db_query('DELETE FROM {field_data_upload} WHERE entity_type = :type AND bundle = :bundle', array(':type' => 'node', ':bundle' => 'project_issue'));
    db_query('DELETE FROM {field_revision_upload} WHERE entity_type = :type AND bundle = :bundle', array(':type' => 'node', ':bundle' => 'project_issue'));

    field_cache_clear();

    // Remove the upload field from project issues -- the field that we use for issues is field_issue_files.
    $instance = field_read_instance('node', 'upload', 'project_issue');
    if ($instance) {
      field_delete_instance($instance);
    }
  }

  public function isComplete() {
    $count = db_query('SELECT COUNT(*) FROM {field_data_upload} WHERE bundle = :bundle', array(':bundle' => 'project_issue'))->fetchField();
    return (bool) ($count == 0);
  }
}

/**
 * Fix general drupal.org data problems.
 */
class ProjectIssueFixGenericCorruptionMigration extends MigrationBase {
  /**
   * General initialization of a ProjectIssueTimelineMigration object.
   */
  public function __construct() {
    parent::__construct();
    $this->description = t('Fix general drupal.org data problems.');
    $this->dependencies = array('ProjectIssueRethreadIssueFollowups');
  }

  protected function import() {
    // @@@ Ensure node.created is sane.

    // Wipe autogenerated comment subjects.
    db_query("UPDATE {comment} c, {project_issue_comments} i SET c.subject = '' WHERE c.subject = CONCAT('#', i.comment_number) AND c.cid = i.cid");
  }

  public function isComplete() {
//    $count = db_query('SELECT COUNT(*) FROM {field_data_upload} WHERE bundle = :bundle', array(':bundle' => 'project_issue'))->fetchField();
//    return (bool) ($count == 0);
  }
}

/**
 * Rethread project_issue comments to match comment_number.
 */
class ProjectIssueRethreadIssueFollowupsMigration extends MigrationBase {
  public function __construct() {
    parent::__construct();
    $this->description = t('WIP: USE AT YOUR OWN RISK! Rethread existing issue comments to match comment_number.');
    //$this->dependencies = array('ProjectIssuePhaseTwo');
  }

  protected function import() {
    if (db_table_exists('project_issue_migration_original_thread')) {
      db_drop_table('project_issue_migration_original_thread');
    }
    db_create_table('project_issue_migration_original_thread', array(
      'fields' => array(
        'cid' => array(
          'type' => 'int',
          'unsigned' => TRUE,
        ),
        'thread' => array(
          'type' => 'varchar',
          'length' => 255,
          'not null' => TRUE,
          'default' => '',
        ),
      ),
      'primary key' => array('cid'),
    ));
    // Store original threads so we can recover from mishaps.
    db_query("INSERT INTO {project_issue_migration_original_thread} (cid, thread) (SELECT cid, thread FROM {comment})");

    db_query("UPDATE {comment} c, {project_issue_comments} i SET c.thread = LOWER(CONCAT(CAST((LENGTH(CAST(CONV(i.comment_number, 10, 36) AS CHAR)) - 1) AS CHAR), CAST(CONV(i.comment_number, 10, 36) AS CHAR), '/')) WHERE c.cid = i.cid");
  }

  public function isComplete() {
    return db_table_exists('project_issue_migration_original_thread');
  }
}

/**
 * Special migration to assemble our full timeline.
 * Part 1: Make original_issue_data accessible by the system.
 * STATUS: DONE
 */
class ProjectIssueTimelinePhaseOneMigration extends MigrationBase {

  public function __construct() {
    parent::__construct();
    $this->description = t('Project issue timeline generator phase 1');
    $this->dependencies = array('ProjectIssueFixInitFiles');
  }

  protected function import() {
    if (db_table_exists('project_issue_migration_original_issue_data')) {
      db_drop_table('project_issue_migration_original_issue_data');
    }
    db_create_table('project_issue_migration_original_issue_data', array(
      'fields' => array(
        'nid' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'not null' => TRUE,
        ),
        'orig_vid' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'description' => 'Initial revision ID assigned when creating issue. (Assumed to be the lowest vid.)'
        ),
        'first_cid' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'description' => 'The cid of the first comment added to the issue node. This is needed for sanity checking.',
        ),
        'title' => array(
          'type' => 'varchar',
          'length' => 255,
          'not null' => FALSE, // Detect missing titles in serialized data...
          'default' => NULL,
        ),
        'pid' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'not null' => FALSE,
          'default' => NULL,
        ),
        'component' => array(
          'type' => 'varchar',
          'length' => 255,
          'not null' => FALSE,
          'default' => NULL,
        ),
        'category' => array(
          'type' => 'varchar',
          'length' => 255,
          'not null' => FALSE,
          'default' => NULL,
        ),
        'priority' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'not null' => FALSE,
          'default' => NULL,
        ),
        'assigned' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'not null' => FALSE,
          'default' => NULL,
        ),
        'sid' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'not null' => FALSE,
          'default' => NULL,
        ),
        'rid' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'not null' => FALSE,
          'default' => NULL,
        ),
      ),
      'primary key' => array('nid'),
      'indexes' => array(
        'orig_vid_idx' => array('orig_vid'),
      ),
    ));

    set_time_limit(0);
    // Step 1: Expand OP data.
    $insertQuery = db_insert('project_issue_migration_original_issue_data')
      ->fields(array('nid', 'orig_vid', 'first_cid', 'title', 'pid', 'component', 'category', 'priority', 'assigned', 'sid', 'rid'));

    // Expand in batches.
    $insertCounter = 0;
    $query = db_select('project_issues', 'p');
    $query->innerJoin('node_revision', 'r', 'p.nid = r.nid');
    $query->leftJoin('comment', 'c', 'p.nid = c.nid');
    $query->addField('p', 'nid');
    $query->addField('p', 'original_issue_data');
    $query->addExpression('MIN(r.vid)', 'orig_vid');
    $query->addExpression('MIN(c.cid)', 'first_cid');
    $query->groupBy('p.nid');
    $result = $query->execute();
    foreach ($result as $row) {
      $data = unserialize($row->original_issue_data);
      $data->nid = $row->nid;
      $insertQuery->values(array(
        'nid' => $data->nid,
        'orig_vid' => $row->orig_vid,
        'first_cid' => $row->first_cid,
        'title' => $data->title,
        'pid' => $data->pid,
        'component' => $data->component,
        'category' => $data->category,
        'priority' => $data->priority,
        'assigned' => $data->assigned,
        'sid' => $data->sid,
        'rid' => $data->rid,
      ));
      $insertCounter++;
      if ($insertCounter > 10000) {
        set_time_limit(0);
        $insertCounter = 0;
        // Flush the mulitple insert periodically.
        $insertQuery->execute();
      }
    }
    if ($insertCounter) {
      $insertQuery->execute();
    }
  }

  protected function rollback() {
    if (db_table_exists('project_issue_migration_original_issue_data')) {
      db_drop_table('project_issue_migration_original_issue_data');
    }
  }

  public function isComplete() {
    return db_table_exists('project_issue_migration_original_issue_data');
  }
}

/**
 * Special migration to assemble our full timeline.
 * Phase 2: Main table / OP injection
 * STATUS: IN PROGRESS
 */
class ProjectIssueTimelinePhaseTwoMigration extends MigrationBase {

  public function __construct() {
    parent::__construct();
    $this->description = t('WIP: USE AT YOUR OWN RISK! Project issue timeline generator phase 2');
    $this->dependencies = array('ProjectIssueTimelinePhaseOne');
  }

  protected function import() {
    if (db_table_exists('project_issue_migration_timeline')) {
      db_drop_table('project_issue_migration_timeline');
    }

    db_create_table('project_issue_migration_timeline', array(
      'fields' => array(
        'nid' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'not null' => TRUE,
        ),
        'prev_nid' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'description' => 'The nid of the previous row, used to speed up the fill algorithm.'
        ),
        'delta' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'not null' => TRUE,
          'default' => 0,
          'description' => 'The delta of this row on a per-node basis, used for the attachment algorithm.'
        ),
        'genid' => array(
          'type' => 'varchar',
          'length' => 255,
          'not null' => TRUE,
        ),
        'prev_genid' => array(
          'type' => 'varchar',
          'length' => 255,
        ),
        'prev_changed_genid' => array(
          'type' => 'varchar',
          'length' => 255,
          'description' => 'Previous genid that is considered changed.'
        ),
        'timestamp' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'not null' => TRUE,
        ),
        /*
        'prev_timestamp' => array(
          'type' => 'int',
          'unsigned' => TRUE,
        ),
        */
        'sort_timestamp' => array(
          'type' => 'int',
          'unsigned' => TRUE,
        ),
        'has_changes' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'size' => 'tiny',
          'not null' => TRUE,
          'default' => 0,
        ),
        'comment_number' => array(
          'type' => 'int',
          'unsigned' => TRUE,
        ),
        'vid' => array(
          'type' => 'int',
          'unsigned' => TRUE,
        ),
        'cid' => array(
          'type' => 'int',
          'unsigned' => TRUE,
        ),
        'tl' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'not null' => TRUE,
          'size' => 'tiny', // 8-bit is fine.
          'default' => ISSUE_MIGRATE_TIMELINE_OP,
          'description' => 'Role in timeline',
        ),
        'last_cid' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'description' => 'Previous cid, used to parent comments generated from existing revisions',
        ),
        // Project fields
        'cur_pid' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'description' => 'CURRENT project id',
        ),
        'prev_pid' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'description' => 'PREVIOUS project id',
        ),
        'cur_component' => array(
          'type' => 'varchar',
          'length' => 255,
          'description' => 'CURRENT component name',
        ),
        'prev_component' => array(
          'type' => 'varchar',
          'length' => 255,
          'description' => 'PREVIOUS component name'
        ),
        'cur_category' => array(
          'type' => 'varchar',
          'length' => 255,
          'description' => 'CURRENT category name'
        ),
        'prev_category' => array(
          'type' => 'varchar',
          'length' => 255,
          'description' => 'PREVIOUS category name'
        ),
        'cur_priority' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'description' => 'CURRENT priority',
        ),
        'prev_priority' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'description' => 'PREVIOUS priority',
        ),
        'cur_assigned' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'description' => 'CURRENT assigned',
        ),
        'prev_assigned' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'description' => 'PREVIOUS assigned',
        ),
        'cur_sid' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'description' => 'CURRENT state',
        ),
        'prev_sid' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'description' => 'PREVIOUS state',
        ),
        'cur_rid' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'description' => 'CURRENT rid',
        ),
        'prev_rid' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'description' => 'PREVIOUS rid',
        ),
        'cur_title' => array(
          'type' => 'varchar',
          'length' => 255,
          'description' => 'CURRENT title',
        ),
        'prev_title' => array(
          'type' => 'varchar',
          'length' => 255,
          'description' => 'PREVIOUS title',
        ),
        'cur_body_value' => array(
          'type' => 'text',
          'size' => 'big',
          'description' => 'CURRENT body value',
        ),
        'prev_body_value' => array(
          'type' => 'text',
          'size' => 'big',
          'description' => 'PREVIOUS body value',
        ),
        'cur_body_summary' => array(
          'type' => 'text',
          'size' => 'big',
          'description' => 'CURRENT body summary',
        ),
        'prev_body_summary' => array(
          'type' => 'text',
          'size' => 'big',
          'description' => 'PREVIOUS body summary',
        ),
        'cur_body_format' => array(
          'type' => 'varchar',
          'length' => 255,
          'description' => 'CURRENT body format',
        ),
        'prev_body_format' => array(
          'type' => 'varchar',
          'length' => 255,
          'description' => 'PREVIOUS body format',
        ),

        'cur_attachments' => array(
          'type' => 'text',
          'size' => 'medium',
          'description' => 'CURRENT attachments (fid,display,description. triple pipe delimited.)',
        ),
        'prev_attachments' => array(
          'type' => 'text',
          'description' => 'PREVIOUS attachments (fid,display,description. triple pipe delimited.)',
        ),
        'cur_tags' => array(
          'type' => 'text',
          'description' => 'CURRENT vid 9 tids (comma separated)',
        ),
        'prev_tags' => array(
          'type' => 'text',
          'description' => 'PREVIOUS vid 9 tids (comma separated)',
        ),
        'comment_body_value' => array(
          'type' => 'text',
          'size' => 'big',
          'description' => 'Body value of comment.',
        ),
        'comment_body_format' => array(
          'type' => 'varchar',
          'length' => 255,
          'description' => 'Format of comment body.',
        ),
        'log' => array(
          'type' => 'text',
          'size' => 'big',
          'description' => 'Log entry for this row.',
        ),
        'uid' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'not null' => TRUE,
          'default' => 0,
        ),
      ),
      'primary key' => array('genid'),
      'indexes' => array(
        'prev_genid_idx' => array('prev_genid'),
        'timestamp_idx' => array('nid', 'timestamp'),
        // Use TL in sorts to ensure that followups and revisions don't happen
        // in the wrong order due to the revision timestamp corruption.
        'sort_idx' => array('nid', 'sort_timestamp', 'tl'),
        'vid_idx' => array('vid'),
        'cid_idx' => array('cid'),
        'delta_idx' => array('delta'),
        'nid_delta_idx' => array('nid', 'delta'),
      ),
    ));

    set_time_limit(0);
    // Serious MySQLism.
    db_query('SET SESSION group_concat_max_len = 1048576');

    // Copy OP 
    $query = db_select('project_issue_migration_original_issue_data', 'd');
    $query->innerJoin('node', 'n', 'd.nid = n.nid');
    $query->innerJoin('node_revision', 'r', 'r.vid = d.orig_vid');
    $query->innerJoin('field_revision_body', 'fb', 'r.vid = fb.revision_id AND fb.entity_type = :type', array(':type' => 'node'));
    $query->leftJoin('field_revision_field_issue_files', 'ff', 'r.vid = ff.revision_id AND ff.entity_type = :type', array(':type' => 'node'));
    $query->leftJoin('comment', 'c', 'd.first_cid = c.cid');
    // cid 0 is for the initial revision.
    // Since editing tags from the node edit form is inhibited, we can base our
    // tag conversion on {comment_alter_taxonomy} instead of worrying about
    // reconciling changes between it and the former {term_node} data.
    $query->leftJoin('comment_alter_taxonomy', 't', 'n.nid = t.nid AND t.cid = 0');

    $query->addField('d', 'nid');
    $query->addExpression('CONCAT(:vid, r.vid)', 'genid', array(':vid' => 'vid-'));
    $query->addField('r', 'vid');
    $query->addExpression("GROUP_CONCAT(CONCAT(ff.field_issue_files_fid, ',', ff.field_issue_files_display, ',', ff.field_issue_files_description) ORDER BY ff.delta ASC SEPARATOR :desc_delim)", 'cur_attachments', array(':desc_delim' => ISSUE_MIGRATE_FILE_DESCRIPTION_DELIMITER));
    $query->addExpression('IFNULL(GROUP_CONCAT(t.tid SEPARATOR :tags_delim), :tags_default)', 'cur_tags', array(':tags_default' => '', ':tags_delim' => ','));
    $query->addField('d', 'pid', 'cur_pid');
    $query->addField('d', 'component', 'cur_component');
    $query->addField('d', 'category', 'cur_category');
    $query->addField('d', 'priority', 'cur_priority');
    $query->addField('d', 'assigned', 'cur_assigned');
    $query->addField('d', 'sid', 'cur_sid');
    $query->addField('d', 'rid', 'cur_rid');
    $query->addField('d', 'title', 'cur_title');
    $query->addExpression('LEAST(n.created, r.timestamp, c.created)', 'sort_timestamp'); // Due to trimming and corruption, node.created is sometimes faulty.
//    $query->addField('n', 'created', 'sort_timestamp'); // Sort goes by creation time to ensure original revision comes first.
    $query->addField('r', 'timestamp');
    $query->addField('r', 'log');
    $query->addField('r', 'uid');
    $query->addField('fb', 'body_value', 'cur_body_value');
    $query->addField('fb', 'body_summary', 'cur_body_summary');
    $query->addField('fb', 'body_format', 'cur_body_format');
    $query->addExpression(':tl', 'tl', array(':tl' => ISSUE_MIGRATE_TIMELINE_OP));

    $query->groupBy('d.nid');

    db_insert('project_issue_migration_timeline')
      ->from($query)
      ->execute();

    // Copy non-initial vids.
    $query = db_select('node_revision', 'r');
    $query->innerJoin('project_issues', 'p', 'r.nid = p.nid');
    $query->leftJoin('project_issue_migration_original_issue_data', 'v', 'r.vid = v.orig_vid');
    $query->innerJoin('field_revision_body', 'fb', 'r.vid = fb.revision_id AND fb.entity_type = :type', array(':type' => 'node'));
    $query->leftJoin('field_revision_field_issue_files', 'ff', 'r.vid = ff.revision_id AND ff.entity_type = :type', array(':type' => 'node'));
    // Ignore initial vid.
    $query->condition('v.orig_vid', NULL, 'IS NULL');

    $query->addField('r', 'nid');
    $query->addExpression('CONCAT(:vid, r.vid)', 'genid', array(':vid' => 'vid-'));
    $query->addField('r', 'vid');
    $query->addExpression("GROUP_CONCAT(CONCAT(ff.field_issue_files_fid, ',', ff.field_issue_files_display, ',', ff.field_issue_files_description) ORDER BY ff.delta ASC SEPARATOR :desc_delim)", 'cur_attachments', array(':desc_delim' => ISSUE_MIGRATE_FILE_DESCRIPTION_DELIMITER));
    $query->addField('r', 'timestamp');
    $query->addField('r', 'timestamp', 'sort_timestamp'); // Unfortunately, node revisions don't keep track of their creation time.
    $query->addField('r', 'log');
    $query->addField('r', 'uid');
    $query->addField('fb', 'body_value', 'cur_body_value');
    $query->addField('fb', 'body_summary', 'cur_body_summary');
    $query->addField('fb', 'body_format', 'cur_body_format');
    $query->addExpression(':tl', 'tl', array(':tl' => ISSUE_MIGRATE_TIMELINE_REVISION));

    $query->groupBy('r.vid');

    db_insert('project_issue_migration_timeline')
      ->from($query)
      ->execute();

    // Copy cids.
    $query = db_select('project_issue_comments', 'p');
    $query->innerJoin('comment', 'c', 'p.cid = c.cid');
    $query->leftJoin('comment_upload', 'cu', 'p.cid = cu.cid');
    $query->innerJoin('field_data_comment_body', 'fb', 'p.cid = fb.entity_id AND fb.entity_type = :type', array(':type' => 'comment'));
    $query->leftJoin('comment_alter_taxonomy', 't', 'p.nid = t.nid AND p.cid = t.cid');

    $query->addField('p', 'nid');
    $query->addExpression('CONCAT(:cid, p.cid)', 'genid', array(':cid' => 'cid-'));
    $query->addField('p', 'cid');
    $query->addExpression("GROUP_CONCAT(CONCAT(cu.fid, ',', cu.list, ',', cu.description) ORDER BY cu.weight ASC SEPARATOR :desc_delim)", 'cur_attachments', array(':desc_delim' => ISSUE_MIGRATE_FILE_DESCRIPTION_DELIMITER));
    $query->addExpression('IFNULL(GROUP_CONCAT(t.tid SEPARATOR :tags_delim), :tags_default)', 'cur_tags', array(':tags_default' => '', ':tags_delim' => ','));
    $query->addField('p', 'pid', 'cur_pid');
    $query->addField('p', 'component', 'cur_component');
    $query->addField('p', 'category', 'cur_category');
    $query->addField('p', 'priority', 'cur_priority');
    $query->addField('p', 'assigned', 'cur_assigned');
    $query->addField('p', 'sid', 'cur_sid');
    $query->addField('p', 'rid', 'cur_rid');
    $query->addField('p', 'title', 'cur_title');
    $query->addField('p', 'comment_number');
    $query->addField('c', 'changed', 'timestamp');
    $query->addField('c', 'created', 'sort_timestamp'); // Sort goes by creation time to ensure original revision comes first.
    //$query->addField('fb', 'comment_body_value', 'log');
    $query->addField('fb', 'comment_body_value', 'comment_body_value');
    $query->addField('fb', 'comment_body_format', 'comment_body_format');
    $query->addField('c', 'uid');
    $query->addExpression(':tl', 'tl', array(':tl' => ISSUE_MIGRATE_TIMELINE_FOLLOWUP));

    $query->groupBy('p.cid');

    db_insert('project_issue_migration_timeline')
      ->from($query)
      ->execute();
  }

  protected function rollback() {
    if (db_table_exists('project_issue_migration_timeline')) {
      db_drop_table('project_issue_migration_timeline');
    }
  }

  public function isComplete() {
    return db_table_exists('project_issue_migration_timeline');
  }
}

/**
 * Special migration to assemble our full timeline.
 * Phase 2: Main table / OP injection
 * STATUS: IN PROGRESS
 */
class ProjectIssueTimelinePhaseThreeMigration extends MigrationBase {

  public function __construct() {
    parent::__construct();
    $this->description = t('WIP: USE AT YOUR OWN RISK! Project issue timeline generator phase 3');
    $this->dependencies = array('ProjectIssueTimelinePhaseTwo');
  }

  protected function import() {
    set_time_limit(0);
    // Serious MySQLism.
    db_query('SET SESSION group_concat_max_len = 1048576');

    $min = 0;
    $max = db_query('SELECT MAX(nid) FROM {node} WHERE type = :type', array(':type' => 'project_issue'))->fetchField();

    db_query("DROP PROCEDURE IF EXISTS project_issue_migrator");
    db_query("CREATE PROCEDURE project_issue_migrator(IN nid_min INT UNSIGNED, IN nid_max INT UNSIGNED)
BEGIN
  DECLARE done INT DEFAULT FALSE;
  DECLARE a INT DEFAULT 0;
  DECLARE b INT DEFAULT 1;
  DECLARE firstline TINYINT UNSIGNED DEFAULT 1;

  DECLARE c_delta INT DEFAULT 0;

  DECLARE c_nid INT UNSIGNED;
  DECLARE p_nid INT UNSIGNED;
  DECLARE c_genid VARCHAR(255) CHARACTER SET utf8;
  DECLARE p_genid VARCHAR(255) CHARACTER SET utf8;
  DECLARE p_changed_genid VARCHAR(255) CHARACTER SET utf8;
  DECLARE c_lastcid INT UNSIGNED;
  DECLARE c_cid INT UNSIGNED;
  DECLARE c_haschanges TINYINT UNSIGNED;
  DECLARE c_tl TINYINT UNSIGNED;

  DECLARE c_body_value LONGTEXT CHARACTER SET utf8;
  DECLARE p_body_value LONGTEXT CHARACTER SET utf8;
  DECLARE c_body_summary LONGTEXT CHARACTER SET utf8;
  DECLARE p_body_summary LONGTEXT CHARACTER SET utf8;
  DECLARE c_body_format VARCHAR(255) CHARACTER SET utf8;
  DECLARE p_body_format VARCHAR(255) CHARACTER SET utf8;
  DECLARE c_pid INT UNSIGNED;
  DECLARE p_pid INT UNSIGNED;
  DECLARE c_component VARCHAR(255) CHARACTER SET utf8;
  DECLARE p_component VARCHAR(255) CHARACTER SET utf8;
  DECLARE c_category VARCHAR(255) CHARACTER SET utf8;
  DECLARE p_category VARCHAR(255) CHARACTER SET utf8;
  DECLARE c_priority INT UNSIGNED;
  DECLARE p_priority INT UNSIGNED;
  DECLARE c_assigned INT UNSIGNED;
  DECLARE p_assigned INT UNSIGNED;
  DECLARE c_sid INT UNSIGNED;
  DECLARE p_sid INT UNSIGNED;
  DECLARE c_rid INT UNSIGNED;
  DECLARE p_rid INT UNSIGNED;
  DECLARE c_title VARCHAR(255) CHARACTER SET utf8;
  DECLARE p_title VARCHAR(255) CHARACTER SET utf8;
  DECLARE c_tags TEXT CHARACTER SET utf8;
  DECLARE p_tags TEXT CHARACTER SET utf8;
  DECLARE x_tags TEXT CHARACTER SET utf8;
  DECLARE c_attachments MEDIUMTEXT CHARACTER SET utf8;
  DECLARE p_attachments MEDIUMTEXT CHARACTER SET utf8;

  DECLARE tl_cur CURSOR FOR
    SELECT nid, genid, cid, tl, cur_body_value, cur_body_summary, cur_body_format, cur_pid, cur_component, cur_category, cur_priority, cur_assigned, cur_sid, cur_rid, cur_title, cur_tags, cur_attachments
    FROM {project_issue_migration_timeline}
    WHERE nid BETWEEN nid_min AND nid_max
    ORDER BY nid ASC, sort_timestamp ASC, tl ASC;
  DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;

  OPEN tl_cur;

  read_loop: LOOP
    FETCH tl_cur INTO c_nid, c_genid, c_cid, c_tl, c_body_value, c_body_summary, c_body_format, c_pid, c_component, c_category, c_priority, c_assigned, c_sid, c_rid, c_title, x_tags, c_attachments;
    IF done THEN
      LEAVE read_loop;
    END IF;
    IF c_nid <> p_nid THEN

      SET p_genid = NULL;
      SET c_delta = 0;

      SET p_body_value    = NULL;
      SET p_body_summary  = NULL;
      SET p_body_format   = NULL;
      SET p_pid           = NULL;
      SET p_component     = NULL;
      SET p_category      = NULL;
      SET p_priority      = NULL;
      SET p_assigned      = NULL;
      SET p_sid           = NULL;
      SET p_rid           = NULL;
      SET p_title         = NULL;
      SET p_tags          = NULL;
      SET p_attachments   = NULL;

      SET c_lastcid       = NULL;
      SET p_changed_genid = NULL;

      SET c_tags          = x_tags;

    END IF;

    IF c_cid IS NOT NULL THEN
      SET c_lastcid = c_cid;
      SET c_tags = x_tags;
    END IF;

    IF c_attachments IS NULL THEN
      SET c_attachments = p_attachments;
    ELSEIF c_attachments <> p_attachments AND p_attachments IS NOT NULL THEN
      SET c_attachments = CONCAT(p_attachments, '" . ISSUE_MIGRATE_FILE_DESCRIPTION_DELIMITER . "', c_attachments);
    END IF;

    SET c_body_value   = IFNULL(c_body_value,   p_body_value);
    SET c_body_summary = IFNULL(c_body_summary, p_body_summary);
    SET c_body_format  = IFNULL(c_body_format,  p_body_format);
    SET c_pid          = IFNULL(c_pid,          p_pid);
    SET c_component    = IFNULL(c_component,    p_component);
    SET c_category     = IFNULL(c_category,     p_category);
    SET c_priority     = IFNULL(c_priority,     p_priority);
    SET c_assigned     = IFNULL(c_assigned,     p_assigned);
    SET c_sid          = IFNULL(c_sid,          p_sid);
    SET c_rid          = IFNULL(c_rid,          p_rid);
    SET c_title        = IFNULL(c_title,        p_title);

    IF c_pid <> p_pid
        OR c_component <> p_component
        OR c_category <> p_category
        OR c_priority <> p_priority
        OR c_assigned <> p_assigned
        OR c_sid <> p_sid
        OR c_rid <> p_rid
        OR c_title <> p_title
        OR c_body_value <> p_body_value
        OR c_body_summary <> p_body_summary
        OR c_body_format <> p_body_format
        OR c_attachments <> p_attachments
        OR c_tags <> p_tags
        OR c_tl = ". ISSUE_MIGRATE_TIMELINE_OP . " THEN
      SET c_haschanges = 1;
    ELSE
      SET c_haschanges = 0;
    END IF;

    UPDATE {project_issue_migration_timeline}
      SET prev_nid           = p_nid,
          prev_genid         = p_genid,
          delta              = c_delta,
          has_changes        = c_haschanges,
          prev_changed_genid = p_changed_genid,
          prev_body_value    = p_body_value,
          cur_body_value     = c_body_value,
          prev_body_summary  = p_body_summary,
          cur_body_summary   = c_body_summary,
          prev_body_format   = p_body_format,
          cur_body_format    = c_body_format,
          prev_pid           = p_pid,
          cur_pid            = c_pid,
          prev_component     = p_component,
          cur_component      = c_component,
          prev_category      = p_category,
          cur_category       = c_category,
          prev_priority      = p_priority,
          cur_priority       = c_priority,
          prev_assigned      = p_assigned,
          cur_assigned       = c_assigned,
          prev_sid           = p_sid,
          cur_sid            = c_sid,
          prev_rid           = p_rid,
          cur_rid            = c_rid,
          prev_title         = p_title,
          cur_title          = c_title,
          prev_tags          = p_tags,
          cur_tags           = c_tags,
          prev_attachments   = p_attachments,
          cur_attachments    = c_attachments,
          last_cid           = c_lastcid
      WHERE genid = c_genid;

    SET p_nid = c_nid;
    SET c_delta = c_delta + 1;
    SET p_genid = c_genid;

    SET p_body_value   = c_body_value;
    SET p_body_summary = c_body_summary;
    SET p_body_format  = c_body_format;
    SET p_pid          = c_pid;
    SET p_component    = c_component;
    SET p_category     = c_category;
    SET p_priority     = c_priority;
    SET p_assigned     = c_assigned;
    SET p_sid          = c_sid;
    SET p_rid          = c_rid;
    SET p_title        = c_title;
    SET p_tags         = c_tags;
    SET p_attachments  = c_attachments;

    IF c_haschanges = 1 THEN
      SET p_changed_genid = c_genid;
    END IF;

  END LOOP;

  CLOSE tl_cur;
END");
    while ($min <= $max) {
      $gmax = $min + 5000;
      // sleep(2); // Drupal.org "play nice with the database" call.
      db_query("CALL project_issue_migrator(:gmin, :gmax)", array(':gmin' => $min, ':gmax' => $gmax));
      set_time_limit(0);
      $min = $gmax;
    }
  }

  protected function rollback() {
    if (db_table_exists('project_issue_migration_timeline')) {
      db_drop_table('project_issue_migration_timeline');
    }
  }

  public function isComplete() {
    return db_table_exists('project_issue_migration_timeline');
  }
}

/**
 * Generate stub node revisions.
 */
class ProjectIssueAllocateVidsMigration extends MigrationBase {
  public function __construct() {
    parent::__construct();
    $this->description = t('WIP: USE AT YOUR OWN RISK! Bulk allocate node revisions for timeline.');
    $this->dependencies = array('ProjectIssueTimelinePhaseThree');
  }

  protected function import() {
    $result = db_query('SELECT t.nid, t.timestamp, t.genid, t.cur_title as title, n.status, n.comment, n.promote, n.sticky, IFNULL(t.log, :logdesc) AS log, t.uid FROM {project_issue_migration_timeline} t INNER JOIN {node} n ON t.nid = n.nid WHERE t.has_changes = 1 AND t.vid IS NULL ORDER BY t.nid ASC, t.sort_timestamp ASC, t.tl ASC', array(':logdesc' => 'Automatically generated revision'));
    foreach ($result as $row) {
      // Generate vid.
      drupal_write_record('node_revision', $row);
      db_update('project_issue_migration_timeline')
        ->fields(array('vid' => $row->vid))
        ->condition('genid', $row->genid)
        ->execute();
    }
    // Fixup current revision of issue nodes.
    db_query('UPDATE {node} n INNER JOIN (SELECT nid, MAX(vid) AS vid FROM {project_issue_migration_timeline} GROUP BY nid) AS t ON n.nid = t.nid SET n.vid = t.vid');
  }

  public function isComplete() {
    if (!db_table_exists('project_issue_migration_timeline')) {
      return FALSE;
    }
    return (db_query('SELECT COUNT(*) FROM {project_issue_migration_timeline} WHERE has_changes = 1 AND vid IS NULL')->fetchField() == 0);
  }
}

/**
 * Generate comments for changed node revisions.
 */
class ProjectIssueAllocateCidsMigration extends MigrationBase {
  public function __construct() {
    parent::__construct();
    $this->description = t('WIP: USE AT YOUR OWN RISK! Bulk allocate comments for timeline.');
    $this->dependencies = array('ProjectIssueTimelinePhaseThree', 'ProjectIssueRethreadIssueFollowups');
  }

  protected function import() {
    $result = db_query('SELECT t.nid, t.timestamp, t.genid, t.uid, IFNULL(t.last_cid, 0) AS last_cid, c.thread, n.status FROM {project_issue_migration_timeline} t LEFT JOIN {comment} c ON c.cid = t.last_cid INNER JOIN {node} n ON t.nid = n.nid WHERE t.has_changes = 1 AND t.cid IS NULL AND tl <> 0 ORDER BY t.nid ASC, t.sort_timestamp ASC, t.tl ASC');
    $lastnid = -1;
    $threadpos = array();
    foreach ($result as $row) {
      if ($row->nid != $lastnid) {
        // Reset the thread positions array.
        $threadpos = array();
        $lastnid = $row->nid;
      }
      // Start counting at zero to match core behavior.
      if (!isset($threadpos[$row->last_cid])) {
        $threadpos[$row->last_cid] = 0;
      }
      else {
        $threadpos[$row->last_cid]++;
      }
      // Assemble the correct thread identifier.
      if (empty($row->thread)) {
        // If there are no comments up to this point in time, use a theoretical comment #0 as the parent.
        // This should prevent conflicts, since the counting would normally start from 1 for comments with parent 0.
        $row->thread = '00/';
      }
      $row->thread = rtrim($row->thread, '/');
      // We prevent conflicts between existing comments and existing revisions by
      // forcing comments generated for existing revisions to always have a parent
      // set. Since this does not happen for existing comments on issues (issues are flat),
      // we can guarantee that no two comments will have the same thread value.
      // This is important, as the thread value is being used in permalinks.
      $row->thread = $row->thread . '.' . int2vancode($threadpos[$row->last_cid]) . '/';

      $row->created = $row->timestamp;
      $row->changed = $row->timestamp;
      $row->subject = ''; // Comments on issues don't have a subject.
      $row->hostname = '127.0.0.1'; // @todo Is this correct?
      $row->language = '';

      // Generate cid.
      drupal_write_record('comment', $row);
      db_update('project_issue_migration_timeline')
        ->fields(array('cid' => $row->cid))
        ->condition('genid', $row->genid)
        ->execute();
    }
  }

  public function isComplete() {
    if (!db_table_exists('project_issue_migration_timeline')) {
      return FALSE;
    }
    return (db_query('SELECT COUNT(*) FROM {project_issue_migration_timeline} WHERE tl <> 0 AND has_changes = 1 AND cid IS NULL')->fetchField() == 0);
  }
}

/**
 * Rebuild comment fields.
 */
class ProjectIssueRebuildCommentFieldsMigration extends MigrationBase {
  public function __construct() {
    parent::__construct();
    $this->description = t('WIP: USE AT YOUR OWN RISK! Inject fields for comments.');
    $this->dependencies = array('ProjectIssueAllocateCids');
  }

  protected function import() {
    // Part 1: Comments generated in ProjectIssueAllocateCids are missing the body field.
    $query = db_select('project_issue_migration_timeline', 't');
    // The rows to use are identified by the tl being revision.
    $query->condition('tl', ISSUE_MIGRATE_TIMELINE_REVISION);
    $query->condition('has_changes', 1);
    $query->addExpression(':entity_type', 'entity_type', array(':entity_type' => 'comment'));
    $query->addExpression(':bundle', 'bundle', array(':bundle' => 'comment_node_project_issue'));
    $query->addExpression(':deleted', 'deleted', array(':deleted' => 0));
    $query->addField('t', 'cid', 'entity_id');
    $query->addField('t', 'cid', 'revision_id');
    $query->addExpression(':language', 'language', array(':language' => LANGUAGE_NONE));
    $query->addExpression(':delta', 'delta', array(':delta' => 0));
    $query->addExpression('IFNULL(t.log, :defaultlog)', 'comment_body_value', array(':defaultlog' => ''));
    // @todo Ensure this is the correct format...
    $query->addExpression(':format', 'comment_body_format', array(':format' => 1));
    $query_c = clone($query);
    db_insert('field_data_comment_body')
      ->from($query)
      ->execute();
    db_insert('field_revision_comment_body')
      ->from($query_c)
      ->execute();

    // Part 2: Assemble field_issue_changes.

    $diff_field_name = nodechanges_get_field_name('comment_node_project_issue');
    $field_info = field_info_field($diff_field_name);

    // Main loop
    $result = db_query('SELECT DISTINCT nid FROM {project_issue_migration_timeline} ORDER BY nid ASC');
    foreach ($result as $row) {
      // Loop per node.
      $items = array();
      $result2 = db_query('SELECT * FROM {project_issue_migration_timeline} WHERE nid = :nid AND has_changes = 1 ORDER BY nid ASC, sort_timestamp ASC, tl ASC', array(':nid' => $row->nid));
      $lastvid = -1;
      foreach ($result2 as $data) {
        if ($data->tl == 0) {
          // The only thing we're using the OP for is to grab the original vid.
          $lastvid = $data->vid;
          continue;
        }
        $node = new stdClass;
        $unchanged = new stdClass;
        $items[$data->cid] = array();

        // Synthesise nodes from the data we loaded from the timeline.
        // We only care about the pieces that nodechanges looks at.

        $node->vid = $data->vid;
        $unchanged->vid = $lastvid;
        $node->language = LANGUAGE_NONE;
        $unchanged->language = LANGUAGE_NONE;
        $node->type = 'project_issue';
        $unchanged->type = 'project_issue';

        // Quick access arrays for data.
        $n = array(&$node, &$unchanged);
        $v = array();
        foreach (array_keys((array)$data) as $key) {
          if (substr($key, 0, 4) == 'cur_') {
            $v[0][substr($key, 4)] = $data->{$key};
          }
          if (substr($key, 0, 5) == 'prev_') {
            $v[1][substr($key, 5)] = $data->{$key};
          }
        }

        foreach (array(0, 1) as $noff) {
          $n[$noff]->body[LANGUAGE_NONE][] = array(
            'value' => $v[$noff]['body_value'],
            'summary' => $v[$noff]['body_summary'],
          );
          $n[$noff]->title = $v[$noff]['title'];

          // @todo This is very d.o specific.
          $tags = explode(',', $v[$noff]['tags']);
          foreach ($tags as $tag) {
            $n[$noff]->taxonomy_vocabulary_9[LANGUAGE_NONE][]['tid'] = $tag;
          }

          if (!empty($v[$noff]['attachments'])) {
            $tmp = explode(ISSUE_MIGRATE_FILE_DESCRIPTION_DELIMITER, $v[$noff]['attachments']);
            $seenfids = array();
            foreach ($tmp as $file) {
              list($fid, $display, $description) = explode(',', $file, 3);
              if (!isset($seenfids[$fid])) {
                $seenfids[$fid] = TRUE;
                $n[$noff]->field_issue_files[LANGUAGE_NONE][] = array(
                  'fid' => $fid,
                  'description' => $description,
                  'display' => $display,
                );
              }
            }
          }

          foreach (array('field_issue_category' => 'category', 'field_issue_component' => 'component', 'field_issue_priority' => 'priority', 'field_issue_status' => 'sid') as $tfield => $sfield) {
            $n[$noff]->{$tfield}[LANGUAGE_NONE][0]['value'] = $v[$noff][$sfield];
          }
          foreach (array('field_issue_assigned' => 'assigned', 'field_project' => 'pid') as $tfield => $sfield) {
            $n[$noff]->{$tfield}[LANGUAGE_NONE][0]['target_id'] = $v[$noff][$sfield];
          }
        }

        // Modified version of nodechanges_node_update().
        foreach ($field_info['settings']['properties'] as $property => $property_name) {
          $token_name = $property;
          // Match node property to token name
          $property = ($property == 'author') ? 'uid' : $property;
          $old_value = empty($unchanged->$property) ? NULL : $unchanged->$property;
          $new_value = empty($node->$property) ? NULL : $node->$property;
          $same = $old_value == $new_value;
          if (!$same && !empty($old_value) && !empty($new_value)) {
            $item = array('field_name' => "node_property:$token_name");
            $item['old_value'] = $unchanged->$property;
            $item['new_value'] = $node->$property;
            $items[$data->cid][] = $item;
          }
        }

        foreach (field_info_instances('node', $node->type) as $field_name => $instance) {
          $field = field_info_field($field_name);
          $old_value = empty($unchanged->{$field_name}[$unchanged->language]) ? NULL : $unchanged->{$field_name}[$unchanged->language];
          $new_value = empty($node->{$field_name}[$node->language]) ? NULL : $node->{$field_name}[$node->language];
          $same = empty($old_value) == empty($new_value);
          if ($same && !empty($old_value)) {
            $old_deltas = array_keys($old_value);
            $new_deltas = array_keys($new_value);
            $same = !array_diff($old_deltas, $new_deltas) && !array_diff($new_deltas, $old_deltas);
            if ($same) {
              $columns = array_keys($field['columns']);
              foreach ($old_value as $delta => $old_items) {
                foreach ($columns as $column) {
                  $set = isset($old_items[$column]);
                  if (($set != isset($new_value[$delta][$column])) || ($set && $old_items[$column] != $new_value[$delta][$column])) {
                    $same = FALSE;
                    break;
                  }
                }
              }
            }
          }
          if (!$same) {
            $item = array('field_name' => $field_name);
            if ($field['type'] == 'text_long' || $field['type'] == 'text_with_summary') {
              $item['old_value'] = $unchanged->vid;
              $item['new_value'] = $node->vid;
            }
            else {
              $item['old_value'] = serialize($old_value);
              $item['new_value'] = serialize($new_value);
            }
            $items[$data->cid][] = $item;
          }
        }
        $lastvid = $data->vid;
      }
      $insertfields = array('entity_type', 'bundle', 'deleted', 'entity_id', 'revision_id', 'language', 'delta', 'field_issue_changes_field_name', 'field_issue_changes_old_value', 'field_issue_changes_new_value');
      $dataq = db_insert('field_data_field_issue_changes')->fields($insertfields);
      $revisionq = db_insert('field_revision_field_issue_changes')->fields($insertfields);
      foreach ($items as $cid => $changes) {
        foreach ($changes as $delta => $change) {
          $record = array(
            'entity_type' => 'comment',
            'bundle' => 'comment_node_project_issue',
            'deleted' => 0,
            'entity_id' => $cid,
            'revision_id' => $cid,
            'language' => LANGUAGE_NONE,
            'delta' => $delta,
            'field_issue_changes_field_name' => $change['field_name'],
            'field_issue_changes_old_value' => $change['old_value'],
            'field_issue_changes_new_value' => $change['new_value'],
          );
          $dataq->values($record);
          $revisionq->values($record);
        }
      }
      $dataq->execute();
      $revisionq->execute();
    }
  }

  public function isComplete() {
    if (!db_table_exists('project_issue_migration_timeline')) {
      return FALSE;
    }
    return (db_query('SELECT COUNT(*) FROM {project_issue_migration_timeline} t LEFT JOIN {field_data_field_issue_changes} c ON t.cid = c.entity_id WHERE t.has_changes = 1 AND c.entity_id IS NULL')->fetchField() == 0);
  }
}

/**
 * Rebuild field tables for issue node revisions.
 */
class ProjectIssueRebuildNodeFieldsMigration extends MigrationBase {
  public function __construct() {
    parent::__construct();
    $this->description = t('WIP: USE AT YOUR OWN RISK! Inject fields for node revisions.');
    $this->dependencies = array('ProjectIssueAllocateVids');
  }

  protected function import() {
    // Part 1: Clear and rebuild body field.
    db_query('DELETE field_data_body FROM field_data_body, node WHERE field_data_body.entity_id = node.nid AND field_data_body.entity_type = :entity_type AND node.type = :type', array(':entity_type' => 'node', ':type' => 'project_issue'));
    db_query('DELETE field_revision_body FROM field_revision_body, node WHERE field_revision_body.entity_id = node.nid AND field_revision_body.entity_type = :entity_type AND node.type = :type', array(':entity_type' => 'node', ':type' => 'project_issue'));

    $query = db_select('project_issue_migration_timeline', 't');
    // Current revision only.
    $query->innerJoin('node', 'n', 't.vid = n.vid');
    $query->addExpression(':entity_type', 'entity_type', array(':entity_type' => 'node'));
    $query->addExpression(':bundle', 'bundle', array(':bundle' => 'project_issue'));
    $query->addExpression(':deleted', 'deleted', array(':deleted' => 0));
    $query->addField('t', 'nid', 'entity_id');
    $query->addField('t', 'vid', 'revision_id');
    $query->addExpression(':language', 'language', array(':language' => LANGUAGE_NONE));
    $query->addExpression(':delta', 'delta', array(':delta' => 0));
    $query->addField('t', 'cur_body_value', 'body_value');
    $query->addField('t', 'cur_body_summary', 'body_summary');
    $query->addField('t', 'cur_body_format', 'body_format');
    db_insert('field_data_body')
      ->from($query)
      ->execute();

    $query = db_select('project_issue_migration_timeline', 't');
    $query->condition('t.vid', NULL, 'IS NOT NULL');
    $query->addExpression(':entity_type', 'entity_type', array(':entity_type' => 'node'));
    $query->addExpression(':bundle', 'bundle', array(':bundle' => 'project_issue'));
    $query->addExpression(':deleted', 'deleted', array(':deleted' => 0));
    $query->addField('t', 'nid', 'entity_id');
    $query->addField('t', 'vid', 'revision_id');
    $query->addExpression(':language', 'language', array(':language' => LANGUAGE_NONE));
    $query->addExpression(':delta', 'delta', array(':delta' => 0));
    $query->addField('t', 'cur_body_value', 'body_value');
    $query->addField('t', 'cur_body_summary', 'body_summary');
    $query->addField('t', 'cur_body_format', 'body_format');
    db_insert('field_revision_body')
      ->from($query)
      ->execute();

    // Part 2: Load other fields.

    // Category field is stored as an integer. Bleh.
    db_delete('field_data_field_issue_category')->condition('bundle', 'project_issue')->execute();
    db_delete('field_revision_field_issue_category')->condition('bundle', 'project_issue')->execute();

    $query = db_select('project_issue_migration_timeline', 't');
    // Current revision only.
    $query->innerJoin('node', 'n', 't.vid = n.vid');
    // Omit nulls.
    $query->condition('cur_category', NULL, 'IS NOT NULL');
    $query->addExpression(':entity_type', 'entity_type', array(':entity_type' => 'node'));
    $query->addExpression(':bundle', 'bundle', array(':bundle' => 'project_issue'));
    $query->addExpression(':deleted', 'deleted', array(':deleted' => 0));
    $query->addField('t', 'nid', 'entity_id');
    $query->addField('t', 'vid', 'revision_id');
    $query->addExpression(':language', 'language', array(':language' => LANGUAGE_NONE));
    $query->addExpression(':delta', 'delta', array(':delta' => 0));
    // Category map in sql.
    $query->addExpression("CASE cur_category WHEN 'feature' THEN 3 WHEN 'bug' THEN 1 WHEN 'support' THEN 4 WHEN 'task' THEN 2 ELSE NULL END", 'field_issue_category_value');
    db_insert("field_data_field_issue_category")
      ->from($query)
      ->execute();

    $query = db_select('project_issue_migration_timeline', 't');
    $query->condition('t.vid', NULL, 'IS NOT NULL');
    // Omit nulls.
    $query->condition('cur_category', NULL, 'IS NOT NULL');
    $query->addExpression(':entity_type', 'entity_type', array(':entity_type' => 'node'));
    $query->addExpression(':bundle', 'bundle', array(':bundle' => 'project_issue'));
    $query->addExpression(':deleted', 'deleted', array(':deleted' => 0));
    $query->addField('t', 'nid', 'entity_id');
    $query->addField('t', 'vid', 'revision_id');
    $query->addExpression(':language', 'language', array(':language' => LANGUAGE_NONE));
    $query->addExpression(':delta', 'delta', array(':delta' => 0));
    // Category map in sql.
    $query->addExpression("CASE cur_category WHEN 'feature' THEN 3 WHEN 'bug' THEN 1 WHEN 'support' THEN 4 WHEN 'task' THEN 2 ELSE NULL END", 'field_issue_category_value');
    db_insert("field_revision_field_issue_category")
      ->from($query)
      ->execute();

    foreach (array('component' => 'component', 'priority' => 'priority', 'status' => 'sid') as $field => $source) {
      db_delete('field_data_field_issue_' . $field)->condition('bundle', 'project_issue')->execute();
      db_delete('field_revision_field_issue_' . $field)->condition('bundle', 'project_issue')->execute();

      $query = db_select('project_issue_migration_timeline', 't');
      // Current revision only.
      $query->innerJoin('node', 'n', 't.vid = n.vid');
      $query->addExpression(':entity_type', 'entity_type', array(':entity_type' => 'node'));
      $query->addExpression(':bundle', 'bundle', array(':bundle' => 'project_issue'));
      $query->addExpression(':deleted', 'deleted', array(':deleted' => 0));
      $query->addField('t', 'nid', 'entity_id');
      $query->addField('t', 'vid', 'revision_id');
      $query->addExpression(':language', 'language', array(':language' => LANGUAGE_NONE));
      $query->addExpression(':delta', 'delta', array(':delta' => 0));
      $query->addField('t', "cur_{$source}", "field_issue_{$field}_value");
      db_insert("field_data_field_issue_{$field}")
        ->from($query)
        ->execute();

      $query = db_select('project_issue_migration_timeline', 't');
      $query->condition('t.vid', NULL, 'IS NOT NULL');
      $query->addExpression(':entity_type', 'entity_type', array(':entity_type' => 'node'));
      $query->addExpression(':bundle', 'bundle', array(':bundle' => 'project_issue'));
      $query->addExpression(':deleted', 'deleted', array(':deleted' => 0));
      $query->addField('t', 'nid', 'entity_id');
      $query->addField('t', 'vid', 'revision_id');
      $query->addExpression(':language', 'language', array(':language' => LANGUAGE_NONE));
      $query->addExpression(':delta', 'delta', array(':delta' => 0));
      $query->addField('t', "cur_{$source}", "field_issue_{$field}_value");
      db_insert("field_revision_field_issue_{$field}")
        ->from($query)
        ->execute();
    }

    // For the version field, we need to join against {project_release_nodes}.
    db_delete('field_data_field_issue_version')->condition('bundle', 'project_issue')->execute();
    db_delete('field_revision_field_issue_version')->condition('bundle', 'project_issue')->execute();

    $query = db_select('project_issue_migration_timeline', 't');
    // Current revision only.
    $query->innerJoin('node', 'n', 't.vid = n.vid');
    // Join against {project_release_nodes} so we can map rid to version string.
    $query->innerJoin('project_release_nodes', 'x', 't.cur_rid = x.nid');
    $query->addExpression(':entity_type', 'entity_type', array(':entity_type' => 'node'));
    $query->addExpression(':bundle', 'bundle', array(':bundle' => 'project_issue'));
    $query->addExpression(':deleted', 'deleted', array(':deleted' => 0));
    $query->addField('t', 'nid', 'entity_id');
    $query->addField('t', 'vid', 'revision_id');
    $query->addExpression(':language', 'language', array(':language' => LANGUAGE_NONE));
    $query->addExpression(':delta', 'delta', array(':delta' => 0));
    $query->addField('x', 'version', 'field_issue_version_value');
    db_insert('field_data_field_issue_version')
      ->from($query)
      ->execute();

    $query = db_select('project_issue_migration_timeline', 't');
    $query->condition('t.vid', NULL, 'IS NOT NULL');
    // Join against {project_release_nodes} so we can map rid to version string.
    $query->innerJoin('project_release_nodes', 'x', 't.cur_rid = x.nid');
    $query->addExpression(':entity_type', 'entity_type', array(':entity_type' => 'node'));
    $query->addExpression(':bundle', 'bundle', array(':bundle' => 'project_issue'));
    $query->addExpression(':deleted', 'deleted', array(':deleted' => 0));
    $query->addField('t', 'nid', 'entity_id');
    $query->addField('t', 'vid', 'revision_id');
    $query->addExpression(':language', 'language', array(':language' => LANGUAGE_NONE));
    $query->addExpression(':delta', 'delta', array(':delta' => 0));
    $query->addField('x', 'version', 'field_issue_version_value');
    db_insert('field_revision_field_issue_version')
      ->from($query)
      ->execute();

    foreach (array('field_issue_assigned' => 'assigned', 'field_project' => 'pid') as $field => $source) {
      db_delete('field_data_' . $field)->condition('bundle', 'project_issue')->execute();
      db_delete('field_revision_' . $field)->condition('bundle', 'project_issue')->execute();

      $query = db_select('project_issue_migration_timeline', 't');
      // Current revision only.
      $query->innerJoin('node', 'n', 't.vid = n.vid');
      // No nulls.
      $query->condition("t.cur_{$source}", NULL, 'IS NOT NULL');
      $query->addExpression(':entity_type', 'entity_type', array(':entity_type' => 'node'));
      $query->addExpression(':bundle', 'bundle', array(':bundle' => 'project_issue'));
      $query->addExpression(':deleted', 'deleted', array(':deleted' => 0));
      $query->addField('t', 'nid', 'entity_id');
      $query->addField('t', 'vid', 'revision_id');
      $query->addExpression(':language', 'language', array(':language' => LANGUAGE_NONE));
      $query->addExpression(':delta', 'delta', array(':delta' => 0));
      $query->addField('t', "cur_{$source}", "{$field}_target_id");
      db_insert("field_data_{$field}")
        ->from($query)
        ->execute();

      $query = db_select('project_issue_migration_timeline', 't');
      $query->condition('t.vid', NULL, 'IS NOT NULL');
      // No nulls.
      $query->condition("t.cur_{$source}", NULL, 'IS NOT NULL');
      $query->addExpression(':entity_type', 'entity_type', array(':entity_type' => 'node'));
      $query->addExpression(':bundle', 'bundle', array(':bundle' => 'project_issue'));
      $query->addExpression(':deleted', 'deleted', array(':deleted' => 0));
      $query->addField('t', 'nid', 'entity_id');
      $query->addField('t', 'vid', 'revision_id');
      $query->addExpression(':language', 'language', array(':language' => LANGUAGE_NONE));
      $query->addExpression(':delta', 'delta', array(':delta' => 0));
      $query->addField('t', "cur_{$source}", "{$field}_target_id");
      db_insert("field_revision_{$field}")
        ->from($query)
        ->execute();
    }

    // Files
    db_delete('field_data_field_issue_files')->condition('bundle', 'project_issue')->execute();
    db_delete('field_revision_field_issue_files')->condition('bundle', 'project_issue')->execute();
    $result = db_query('SELECT t.nid, t.vid, n.vid AS n_vid, t.cur_attachments FROM {project_issue_migration_timeline} t INNER JOIN {node} n ON t.nid = n.nid WHERE t.vid IS NOT NULL and t.cur_attachments IS NOT NULL');
    $fields = array('entity_type', 'bundle', 'deleted', 'entity_id', 'revision_id', 'language', 'delta', 'field_issue_files_fid', 'field_issue_files_display', 'field_issue_files_description');
    foreach ($result as $row) {
      $values = array();
      $seenfids = array();
      foreach (explode(ISSUE_MIGRATE_FILE_DESCRIPTION_DELIMITER, $row->cur_attachments) as $delta => $data) {
        list($fid, $display, $description) = explode(',', $data, 3);
        if (!isset($seenfids[$fid])) {
          $seenfids[$fid] = TRUE;
          $values[] = array(
            'entity_type' => 'node',
            'bundle' => 'project_issue',
            'deleted' => 0,
            'entity_id' => $row->nid,
            'revision_id' => $row->vid,
            'language' => LANGUAGE_NONE,
            'delta' => $delta,
            'field_issue_files_fid' => $fid,
            'field_issue_files_display' => $display,
            'field_issue_files_description' => $description,
          );
        }
      }
      if (!empty($values)) {
        $insertq = db_insert('field_revision_field_issue_files')->fields($fields);
        foreach ($values as $value) {
          $insertq->values($value);
        }
        $insertq->execute();
        if ($row->vid == $row->n_vid) {
          // Copy the most recent revision to the field data.
          $insertq = db_insert('field_data_field_issue_files')->fields($fields);
          foreach ($values as $value) {
            $insertq->values($value);
          }
          $insertq->execute();
        }
      }
    }
    // Update file usage.
    db_query('DELETE {file_usage} FROM {file_usage}, {field_revision_field_issue_files} WHERE {file_usage}.fid = {field_revision_field_issue_files}.field_issue_files_fid');
    db_query("INSERT INTO {file_usage} (fid, module, type, id, count) (SELECT field_issue_files_fid, 'file', 'node', entity_id, COUNT(*) FROM {field_revision_field_issue_files} GROUP BY entity_id, field_issue_files_fid)");

    // @todo This is drupal.org specific.
    db_query('DELETE {taxonomy_index} FROM {taxonomy_index}, {node}, {taxonomy_term_data} WHERE {taxonomy_index}.nid = {node}.nid AND {taxonomy_index}.tid = {taxonomy_term_data}.tid AND {taxonomy_term_data}.vid = :vid AND {node}.type = :type', array(':vid' => ISSUE_MIGRATE_TAGS_VID, ':type' => 'project_issue'));
    db_delete('field_data_taxonomy_vocabulary_' . ISSUE_MIGRATE_TAGS_VID)->condition('bundle', 'project_issue')->execute();
    db_delete('field_revision_taxonomy_vocabulary_' . ISSUE_MIGRATE_TAGS_VID)->condition('bundle', 'project_issue')->execute();

    $result = db_query("SELECT t.nid, t.vid, n.vid AS n_vid, t.cur_tags FROM {project_issue_migration_timeline} t INNER JOIN {node} n ON t.nid = n.nid WHERE t.vid IS NOT NULL AND t.cur_tags IS NOT NULL AND t.cur_tags <> ''");
    $fields = array('entity_type', 'bundle', 'deleted', 'entity_id', 'revision_id', 'language', 'delta', 'taxonomy_vocabulary_' . ISSUE_MIGRATE_TAGS_VID . '_tid');
    foreach ($result as $row) {
      $values = array();
      foreach (explode(',', $row->cur_tags) as $delta => $tid) {
        $values[] = array(
          'entity_type' => 'node',
          'bundle' => 'project_issue',
          'deleted' => 0,
          'entity_id' => $row->nid,
          'revision_id' => $row->vid,
          'language' => LANGUAGE_NONE,
          'delta' => $delta,
          'taxonomy_vocabulary_' . ISSUE_MIGRATE_TAGS_VID . '_tid' => $tid,
        );
      }
      if (!empty($values)) {
        $insertq = db_insert('field_revision_taxonomy_vocabulary_' . ISSUE_MIGRATE_TAGS_VID)->fields($fields);
        foreach ($values as $value) {
          $insertq->values($value);
        }
        $insertq->execute();
        if ($row->vid == $row->n_vid) {
          // Copy the most recent revision to the field_data.
          $insertq = db_insert('field_data_taxonomy_vocabulary_' . ISSUE_MIGRATE_TAGS_VID)->fields($fields);
          foreach ($values as $value) {
            $insertq->values($value);
          }
          $insertq->execute();
        }
      }
    }
    // Bulk update {taxonomy_index}.
    db_query("INSERT INTO {taxonomy_index} (nid, tid, sticky, created) (SELECT f.entity_id, f.taxonomy_vocabulary_" . ISSUE_MIGRATE_TAGS_VID . "_tid, n.sticky, n.created FROM {field_data_taxonomy_vocabulary_" . ISSUE_MIGRATE_TAGS_VID . "} f INNER JOIN {node} n ON f.entity_id = n.nid AND f.entity_type = 'node' WHERE n.status = 1)");
  }

  public function isComplete() {
    if (!db_table_exists('project_issue_migration_timeline')) {
      return FALSE;
    }
    return (db_query('SELECT COUNT(*) FROM {project_issue_migration_timeline} WHERE vid IS NULL')->fetchField() == 0);
  }
}

/**
 * Map category names to integers.
 */
function _project_issue_map_category($value) {
  switch ($value) {
    case 'feature':
      return 3;
    case 'bug':
      return 1;
    case 'support':
      return 4;
    case 'task':
      return 2;
    default:
      return 0;
  }
}

/**
 * Map rids to version strings.
 */
function _project_issue_map_version($value) {
  static $vdata = array();
  if (!isset($vdata[$value])) {
    $vdata[$value] = db_query('SELECT version FROM {project_release_nodes} WHERE nid = :nid', array(':nid' => $value))->fetchField();
  }
  return $vdata[$value];
}
